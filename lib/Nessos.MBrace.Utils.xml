<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Nessos.MBrace.Utils</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.AtomicCounter">
<summary>
 thread safe counter implementation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.CacheAtom`1">
<summary>
 thread safe cache with expiry semantics
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.HostId">
<summary>
 a heuristic host identifier
 an id generated by the local computer
 should be able to uniquely identify it within the context
 of all possible subnets/domain names that connect to it
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.ProjectionComparison`2">
<summary>
 inherit this class if you want to scrap all the comparison boilerplate
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Array">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Assembly">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.afailwithf``2(Microsoft.FSharp.Core.PrintfFormat{Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 async failwithf
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.afailwith``1(System.String)">
<summary>
 async failwith
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.Choice.Static``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 nondeterministic choice
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.Run.Static``1(Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 a more functional RunSynchronously wrapper
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.Raise.Static``2(``0)">
<summary>
 eficient raise
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.AwaitTask.Static``1(System.Threading.Tasks.Task{``0},System.Int32)">
<summary>
 non-blocking awaitTask with timeout
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.AwaitTask.Static(System.Threading.Tasks.Task)">
<summary>
 untyped awaitTask
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Seq.pExists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 parallel exists
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Seq.pForall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
<summary>
 parallel forall
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Seq.pTryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 parallel tryPick
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Seq.pPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 parallel pick
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.AsyncExtensions.Seq">

</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 nondeterministic existential
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 nondeterministic forall
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 nondeterministic pick
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``1}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 nodeterministic pick
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.lift``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 lifting of lambdas to async funcs
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.AsyncExtensions.Async.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 postcompose covariant operation
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.AsyncExtensions.Async">

</member>
<member name="T:Nessos.MBrace.Utils.AsyncExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Atom">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Buffer">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Exiter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.Boolean">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.Set">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.Map">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.Choice">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Extensions.List.parChoose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 List.choose wrapper for Async.Parallel
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Extensions.List.parMap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 List.map wrapper for Async.Parallel
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.List">

</member>
<member name="M:Nessos.MBrace.Utils.Extensions.Seq.parMap``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 a wrapper for Async.Parallel
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.Seq">

</member>
<member name="M:Nessos.MBrace.Utils.Extensions.Option.bind2``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``1,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 match t with None -&gt; s | Some t0 -&gt; f t0
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Extensions.Option.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 returns the head of a list if nonempty
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions.Option">

</member>
<member name="T:Nessos.MBrace.Utils.Extensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.FixedStream.FixedSizeStream">
<summary>
 A stream wrapper that fails when the size of the stream gt maxSize.
 &apos;Write&apos;-only, no data actually written.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.FixedStream">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.LazyList.LazyList">

</member>
<member name="T:Nessos.MBrace.Utils.LazyList">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Logger.create(Microsoft.FSharp.Core.FSharpFunc{Nessos.MBrace.Utils.LogEntry,Microsoft.FSharp.Core.Unit})">
 <summary>Constructs an abstract Logger</summary>
 <param name="append">the append log entry behavior.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Logger">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Process">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Queue.Queue">

</member>
<member name="T:Nessos.MBrace.Utils.Queue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Quotations.QuotationsTreeModule.iter(Microsoft.FSharp.Core.FSharpFunc{Nessos.MBrace.Utils.Quotations.Quotation,Microsoft.FSharp.Core.Unit},Nessos.MBrace.Utils.Quotations.QuotationsTree)">
<summary>
 iterates through a quotation tree
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Quotations.QuotationsTreeModule.create(Microsoft.FSharp.Core.FSharpFunc{Nessos.MBrace.Utils.Quotations.MethodOrProperty,System.Boolean},Microsoft.FSharp.Quotations.FSharpExpr)">
 <summary>build a tree of reflected definition calls based on original expr</summary>
 <param name="traverseP">this predicate decides whether given reflected method should be further traversed.</param>
 <param name="expr">the original quotation.</param>
</member>
<member name="T:Nessos.MBrace.Utils.Quotations.QuotationsTreeModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Quotations.Expr.substitute(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 recursively substitutes the branches of a quotation based on given rule
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Quotations.Expr.erase(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 erase reflected type from quotation
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Quotations.Expr">

</member>
<member name="T:Nessos.MBrace.Utils.Quotations">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Reflection.rootType(System.Type)">
<summary>
 returns the root type/module containing the type
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Reflection.gatherTypes(System.Object)">
<summary>
 gather all types within an object graph
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Reflection.isSealedPattern(System.Type)">
<summary>
 this predicate recognizes type patterns whose components are sealed types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.MBrace.Utils.Reflection.|FSharpFunc|_|">
<summary>
 matches against lambda types, returning a tuple ArgType [] * ResultType
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Reflection.GacTools.lookupPartial(System.String)">
<summary>
 looks up gac by partial assembly name
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Reflection.GacTools">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Reflection.Primitives">

</member>
<member name="T:Nessos.MBrace.Utils.Reflection">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.MBrace.Utils.Retry.RetryPolicy.NoRetry">
<summary>
 no retries performed
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Retry.RetryPolicy.Retry(System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Double})">
<summary>
 performs given number of retries
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Retry.RetryPolicy.Infinite(Microsoft.FSharp.Core.FSharpOption{System.Double})">
<summary>
 performs infinitely many retries until operation succeeds
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Retry.RetryPolicy.Filter``1(Microsoft.FSharp.Core.FSharpOption{System.Double})">
<summary>
 only perform retries while exception of given type is caught
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Retry.RetryPolicy.ExponentialDelay(System.Int32,System.Double)">
<summary>
 doubles the delay interval after every retry
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Retry.RetryPolicy.DelayMap(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Double})">
<summary>
 maps delay time w.r.t number of performed retries
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Retry.retryAsync``1(Nessos.MBrace.Utils.Retry.RetryPolicy,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 retries given action based on given policy
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Retry.retry``1(Nessos.MBrace.Utils.Retry.RetryPolicy,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 retries given action based on policy
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.Retry">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.RevAsyncUtils.List">

</member>
<member name="M:Nessos.MBrace.Utils.RevAsyncUtils.RevAsync.rafailwithf``2(Microsoft.FSharp.Core.PrintfFormat{Nessos.MBrace.Utils.Reversible.RevAsync{``0},Microsoft.FSharp.Core.Unit,System.String,Nessos.MBrace.Utils.Reversible.RevAsync{``1}})">
<summary>
 revasync failwithf
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.RevAsyncUtils.RevAsync.rafailwith``1(System.String)">
<summary>
 revasync failwith
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.RevAsyncUtils.RevAsync.lift``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 lifting of lambdas to revasync funcs
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.RevAsyncUtils.RevAsync.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Nessos.MBrace.Utils.Reversible.RevAsync{``0})">
<summary>
 postcompose covariant operation
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.RevAsyncUtils.RevAsync">

</member>
<member name="T:Nessos.MBrace.Utils.RevAsyncUtils">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Reversible.PublicAPI">

</member>
<member name="M:Nessos.MBrace.Utils.Reversible.Async.zero``1(``0)">
<summary>
 polymorphic Async.Zero with ignore semantics
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.Reversible.Async">

</member>
<member name="T:Nessos.MBrace.Utils.Reversible">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.String.prettyPrintTable3``1(Microsoft.FSharp.Collections.FSharpList{Nessos.MBrace.Utils.String.Field{``0}},Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 pretty print with no grouping
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.String.prettyPrintTable2``1(Microsoft.FSharp.Collections.FSharpList{Nessos.MBrace.Utils.String.Field{``0}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 pretty print with discrete groupings
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.String.prettyPrintTable``1(Microsoft.FSharp.Collections.FSharpList{Nessos.MBrace.Utils.String.Field{``0}},Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 pretty print with grouped entries
 input is given as a collection of lists to group together wrt horizontal separators
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.String.Field">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.String.Convert">

</member>
<member name="M:Nessos.MBrace.Utils.String.String.indentWith(System.String,System.String)">
<summary>
 quick &apos;n&apos; dirty indentation insertion
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.String.String">

</member>
<member name="T:Nessos.MBrace.Utils.String">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.Substream.Substream">
<summary>
 A stream wrapper that sets as position 0L a given offset of the
 underlying stream.
 Please find a better name for this one.
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.Substream">

</member>
<member name="M:Nessos.MBrace.Utils.ThreadSafe.tryClaimGlobalMutex(System.String)">
<summary>
 will only return a mutex if name hasn&apos;t been claimed yet
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.MBrace.Utils.ThreadSafe">
<summary>
 thread-safe operators
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.MBrace.Utils.Utils.|RegexMatch|_|">
<summary>
 memoized regex active pattern
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.sprintf'``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,System.String})">
<summary>
 fast sprintf
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.hset``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 mutable hashset combinator
</summary>
</member>
<member name="P:Nessos.MBrace.Utils.Utils.maybe">
<summary>
 optional monad
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.tryMe``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 try Some &lt;| f () with ex -&gt; None
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Utils.contain``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 try Choice1Of2 &lt;| f () with e -&gt; Choice2Of2 e
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.getIdGenerator(System.Int32)">
<summary>
 an incrementing id generator that begins at given id
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.getAvailableTcpPorts(System.Int32)">
<summary>
 a really, *really* bad way of getting available tcp ports
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.runOnce``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 wraps the function in a memoized context
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.MBrace.Utils.Utils.compareOn``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,System.Object)">
<summary>
 projective comparison
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.hashOn``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 projective hashcode
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.equalsOn``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0,System.Object)">
<summary>
 projective equality
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.memoizeBy``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 memoization with comparison delegate
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.Ymemoize``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 memoizing fixpoint combinator
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.tryMemoize``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}})">
<summary>
 only memoize successful results of given function
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.memoize``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 higher-order thread-safe memoizer operator
</summary>
</member>
<member name="P:Nessos.MBrace.Utils.Utils.processUUID">
<summary>
 a guid that identifies this specific AppDomain
</summary>
</member>
<member name="P:Nessos.MBrace.Utils.Utils.isConsoleWindow">
<summary>
 determines if current process runs in console window
</summary>
</member>
<member name="P:Nessos.MBrace.Utils.Utils.selfProc">
<summary>
 System.Diagnostics.Process.GetCurrentProcess()
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.denull``1(``0)">
<summary>
 strips nullable types
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.throwInvalidState``2(``0)">
<summary>
 raise exception with given object
</summary>
</member>
<member name="M:Nessos.MBrace.Utils.Utils.raise``1(System.Exception)">
<summary>
 a raise operator that does not appear in the stack trace
</summary>
</member>
<member name="T:Nessos.MBrace.Utils.Utils">

</member>
</members>
</doc>
